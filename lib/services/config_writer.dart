import '../models/yabai_config.dart';
import '../models/skhd_config.dart';
import '../models/window_rule.dart';
import '../models/signal.dart';

/// Service for generating yabai and skhd configuration file content
class ConfigWriter {
  /// Generate .yabairc file content from a YabaiConfig object
  /// This delegates to the model's toYabairc() method for consistency
  static String generateYabairc(YabaiConfig config) {
    return config.toYabairc();
  }

  /// Generate .skhdrc file content from a SkhdConfig object
  /// This delegates to the model's toSkhdrc() method for consistency
  static String generateSkhdrc(SkhdConfig config) {
    return config.toSkhdrc();
  }

  /// Generate a custom yabairc with additional formatting options
  static String generateCustomYabairc(
    YabaiConfig config, {
    bool includeHeader = true,
    bool groupBySection = true,
    String? headerComment,
  }) {
    final buffer = StringBuffer();

    if (includeHeader) {
      buffer.writeln('#!/usr/bin/env sh');
      buffer.writeln();
      if (headerComment != null) {
        buffer.writeln('# $headerComment');
      } else {
        buffer.writeln('# ============================');
        buffer.writeln('# Yabai Configuration');
        buffer.writeln('# Generated by Yabai Config');
        buffer.writeln('# ============================');
      }
      buffer.writeln();
    }

    if (groupBySection) {
      _writeGroupedYabaiConfig(buffer, config);
    } else {
      _writeFlatYabaiConfig(buffer, config);
    }

    buffer.writeln();
    buffer.writeln('echo "yabai configuration loaded..."');

    return buffer.toString();
  }

  /// Write yabai config grouped by sections
  static void _writeGroupedYabaiConfig(StringBuffer buffer, YabaiConfig config) {
    // Layout settings
    buffer.writeln('# === Layout ===');
    buffer.writeln('yabai -m config layout ${config.layout}');
    buffer.writeln('yabai -m config window_placement ${config.windowPlacement}');
    buffer.writeln('yabai -m config auto_balance ${_formatBool(config.autoBalance)}');
    buffer.writeln('yabai -m config split_ratio ${config.splitRatio}');
    buffer.writeln('yabai -m config split_type ${config.splitType}');
    buffer.writeln();

    // Gaps and padding
    buffer.writeln('# === Gaps and Padding ===');
    buffer.writeln('yabai -m config window_gap ${config.windowGap}');
    buffer.writeln('yabai -m config top_padding ${config.topPadding}');
    buffer.writeln('yabai -m config bottom_padding ${config.bottomPadding}');
    buffer.writeln('yabai -m config left_padding ${config.leftPadding}');
    buffer.writeln('yabai -m config right_padding ${config.rightPadding}');
    buffer.writeln();

    // External bar (if configured)
    if (config.externalBar != null) {
      buffer.writeln('# === External Bar ===');
      buffer.writeln('yabai -m config external_bar ${config.externalBar}');
      buffer.writeln();
    }

    // Mouse settings
    buffer.writeln('# === Mouse ===');
    buffer.writeln('yabai -m config mouse_follows_focus ${_formatBool(config.mouseFollowsFocus)}');
    buffer.writeln('yabai -m config focus_follows_mouse ${config.focusFollowsMouse}');
    buffer.writeln('yabai -m config mouse_modifier ${config.mouseModifier}');
    buffer.writeln('yabai -m config mouse_action1 ${config.mouseAction1}');
    buffer.writeln('yabai -m config mouse_action2 ${config.mouseAction2}');
    buffer.writeln('yabai -m config mouse_drop_action ${config.mouseDropAction}');
    buffer.writeln();

    // Window appearance
    buffer.writeln('# === Window Appearance ===');
    buffer.writeln('yabai -m config window_opacity ${_formatBool(config.windowOpacity)}');
    if (config.windowOpacity) {
      buffer.writeln('yabai -m config active_window_opacity ${config.activeWindowOpacity}');
      buffer.writeln('yabai -m config normal_window_opacity ${config.normalWindowOpacity}');
    }
    buffer.writeln('yabai -m config window_shadow ${config.windowShadow}');
    buffer.writeln('yabai -m config window_animation_duration ${config.windowAnimationDuration}');
    buffer.writeln();

    // Window borders
    buffer.writeln('# === Window Borders ===');
    buffer.writeln('yabai -m config window_border ${_formatBool(config.windowBorder)}');
    if (config.windowBorder) {
      buffer.writeln('yabai -m config window_border_width ${config.windowBorderWidth}');
      buffer.writeln('yabai -m config active_window_border_color ${config.activeWindowBorderColor}');
      buffer.writeln('yabai -m config normal_window_border_color ${config.normalWindowBorderColor}');
      buffer.writeln('yabai -m config insert_feedback_color ${config.insertFeedbackColor}');
    }
    buffer.writeln();

    // Space configurations
    if (config.spaces.isNotEmpty) {
      buffer.writeln('# === Space Configurations ===');
      for (final space in config.spaces) {
        for (final cmd in space.toYabaiCommands()) {
          buffer.writeln(cmd);
        }
      }
      buffer.writeln();
    }

    // Window rules
    if (config.rules.isNotEmpty) {
      buffer.writeln('# === Window Rules ===');
      for (final rule in config.rules) {
        if (rule.enabled) {
          for (final cmd in rule.toYabaiCommands()) {
            buffer.writeln(cmd);
          }
        }
      }
      buffer.writeln();
    }

    // Signals
    if (config.signals.isNotEmpty) {
      buffer.writeln('# === Signals ===');
      for (final signal in config.signals) {
        if (signal.enabled) {
          final cmd = signal.toYabaiCommand();
          if (cmd.isNotEmpty) {
            buffer.writeln(cmd);
          }
        }
      }
    }
  }

  /// Write yabai config without section grouping
  static void _writeFlatYabaiConfig(StringBuffer buffer, YabaiConfig config) {
    // All config settings
    buffer.writeln('yabai -m config layout ${config.layout}');
    buffer.writeln('yabai -m config window_placement ${config.windowPlacement}');
    buffer.writeln('yabai -m config auto_balance ${_formatBool(config.autoBalance)}');
    buffer.writeln('yabai -m config split_ratio ${config.splitRatio}');
    buffer.writeln('yabai -m config split_type ${config.splitType}');
    buffer.writeln('yabai -m config window_gap ${config.windowGap}');
    buffer.writeln('yabai -m config top_padding ${config.topPadding}');
    buffer.writeln('yabai -m config bottom_padding ${config.bottomPadding}');
    buffer.writeln('yabai -m config left_padding ${config.leftPadding}');
    buffer.writeln('yabai -m config right_padding ${config.rightPadding}');
    if (config.externalBar != null) {
      buffer.writeln('yabai -m config external_bar ${config.externalBar}');
    }
    buffer.writeln('yabai -m config mouse_follows_focus ${_formatBool(config.mouseFollowsFocus)}');
    buffer.writeln('yabai -m config focus_follows_mouse ${config.focusFollowsMouse}');
    buffer.writeln('yabai -m config mouse_modifier ${config.mouseModifier}');
    buffer.writeln('yabai -m config mouse_action1 ${config.mouseAction1}');
    buffer.writeln('yabai -m config mouse_action2 ${config.mouseAction2}');
    buffer.writeln('yabai -m config mouse_drop_action ${config.mouseDropAction}');
    buffer.writeln('yabai -m config window_opacity ${_formatBool(config.windowOpacity)}');
    buffer.writeln('yabai -m config active_window_opacity ${config.activeWindowOpacity}');
    buffer.writeln('yabai -m config normal_window_opacity ${config.normalWindowOpacity}');
    buffer.writeln('yabai -m config window_shadow ${config.windowShadow}');
    buffer.writeln('yabai -m config window_animation_duration ${config.windowAnimationDuration}');
    buffer.writeln('yabai -m config window_border ${_formatBool(config.windowBorder)}');
    buffer.writeln('yabai -m config window_border_width ${config.windowBorderWidth}');
    buffer.writeln('yabai -m config active_window_border_color ${config.activeWindowBorderColor}');
    buffer.writeln('yabai -m config normal_window_border_color ${config.normalWindowBorderColor}');
    buffer.writeln('yabai -m config insert_feedback_color ${config.insertFeedbackColor}');
    buffer.writeln();

    // Space configurations
    for (final space in config.spaces) {
      for (final cmd in space.toYabaiCommands()) {
        buffer.writeln(cmd);
      }
    }

    // Rules
    for (final rule in config.rules) {
      if (rule.enabled) {
        for (final cmd in rule.toYabaiCommands()) {
          buffer.writeln(cmd);
        }
      }
    }

    // Signals
    for (final signal in config.signals) {
      if (signal.enabled) {
        final cmd = signal.toYabaiCommand();
        if (cmd.isNotEmpty) {
          buffer.writeln(cmd);
        }
      }
    }
  }

  /// Generate a custom skhdrc with additional formatting options
  static String generateCustomSkhdrc(
    SkhdConfig config, {
    bool includeHeader = true,
    bool groupByCategory = true,
    String? headerComment,
  }) {
    final buffer = StringBuffer();

    if (includeHeader) {
      if (headerComment != null) {
        buffer.writeln('# $headerComment');
      } else {
        buffer.writeln('# ============================');
        buffer.writeln('# skhd Configuration');
        buffer.writeln('# Generated by Yabai Config');
        buffer.writeln('# ============================');
      }
      buffer.writeln();
    }

    if (groupByCategory) {
      _writeGroupedSkhdConfig(buffer, config);
    } else {
      _writeFlatSkhdConfig(buffer, config);
    }

    return buffer.toString();
  }

  /// Write skhd config grouped by categories
  static void _writeGroupedSkhdConfig(StringBuffer buffer, SkhdConfig config) {
    // Group shortcuts by category
    final grouped = <String?, List<Shortcut>>{};
    for (final shortcut in config.shortcuts) {
      if (shortcut.enabled) {
        grouped.putIfAbsent(shortcut.category, () => []).add(shortcut);
      }
    }

    // Sort categories with known ones first
    final categoryOrder = ['focus', 'move', 'resize', 'layout', 'space', 'display', 'custom', null];
    final sortedKeys = grouped.keys.toList()
      ..sort((a, b) {
        final aIndex = categoryOrder.indexOf(a);
        final bIndex = categoryOrder.indexOf(b);
        if (aIndex == -1 && bIndex == -1) return 0;
        if (aIndex == -1) return 1;
        if (bIndex == -1) return -1;
        return aIndex.compareTo(bIndex);
      });

    // Write each category
    for (final category in sortedKeys) {
      final categoryName = category != null
          ? ShortcutCategory.fromString(category)?.displayName ?? category
          : 'Uncategorized';
      buffer.writeln('# === $categoryName ===');
      for (final shortcut in grouped[category]!) {
        _writeShortcut(buffer, shortcut);
      }
      buffer.writeln();
    }
  }

  /// Write skhd config without category grouping
  static void _writeFlatSkhdConfig(StringBuffer buffer, SkhdConfig config) {
    for (final shortcut in config.shortcuts) {
      if (shortcut.enabled) {
        _writeShortcut(buffer, shortcut);
      }
    }
  }

  /// Write a single Shortcut
  static void _writeShortcut(StringBuffer buffer, Shortcut shortcut) {
    if (shortcut.description != null) {
      buffer.writeln('# ${shortcut.description}');
    }
    buffer.writeln(shortcut.toSkhdLine());
  }

  /// Generate a single rule command
  static String generateRuleCommand(WindowRule rule) {
    if (!rule.enabled) return '';
    return rule.toYabaiCommands().join('\n');
  }

  /// Generate a single signal command
  static String generateSignalCommand(YabaiSignal signal) {
    if (!signal.enabled) return '';
    return signal.toYabaiCommand();
  }

  /// Generate a single shortcut line
  static String generateShortcutLine(Shortcut shortcut) {
    return shortcut.toSkhdLine();
  }

  /// Format a boolean value for yabai config
  static String _formatBool(bool value) {
    return value ? 'on' : 'off';
  }

  /// Format a value for yabai config (handles various types)
  static String formatValue(dynamic value) {
    if (value is bool) {
      return _formatBool(value);
    }
    if (value is String && value.contains(' ')) {
      return '"$value"';
    }
    return value.toString();
  }

  /// Validate that a YabaiConfig can be properly serialized
  static List<String> validateConfig(YabaiConfig config) {
    final errors = <String>[];

    // Validate layout
    if (!YabaiConfig.validLayouts.contains(config.layout)) {
      errors.add('Invalid layout: ${config.layout}');
    }

    // Validate window placement
    if (!YabaiConfig.validPlacements.contains(config.windowPlacement)) {
      errors.add('Invalid window_placement: ${config.windowPlacement}');
    }

    // Validate mouse modifier
    if (!YabaiConfig.validMouseModifiers.contains(config.mouseModifier)) {
      errors.add('Invalid mouse_modifier: ${config.mouseModifier}');
    }

    // Validate mouse actions
    if (!YabaiConfig.validMouseActions.contains(config.mouseAction1)) {
      errors.add('Invalid mouse_action1: ${config.mouseAction1}');
    }
    if (!YabaiConfig.validMouseActions.contains(config.mouseAction2)) {
      errors.add('Invalid mouse_action2: ${config.mouseAction2}');
    }

    // Validate split ratio
    if (config.splitRatio < 0.0 || config.splitRatio > 1.0) {
      errors.add('split_ratio must be between 0.0 and 1.0');
    }

    // Validate opacity values
    if (config.activeWindowOpacity < 0.0 || config.activeWindowOpacity > 1.0) {
      errors.add('active_window_opacity must be between 0.0 and 1.0');
    }
    if (config.normalWindowOpacity < 0.0 || config.normalWindowOpacity > 1.0) {
      errors.add('normal_window_opacity must be between 0.0 and 1.0');
    }

    // Validate padding values (should be non-negative)
    if (config.windowGap < 0) errors.add('window_gap must be non-negative');
    if (config.topPadding < 0) errors.add('top_padding must be non-negative');
    if (config.bottomPadding < 0) errors.add('bottom_padding must be non-negative');
    if (config.leftPadding < 0) errors.add('left_padding must be non-negative');
    if (config.rightPadding < 0) errors.add('right_padding must be non-negative');

    // Validate rules
    for (int i = 0; i < config.rules.length; i++) {
      final rule = config.rules[i];
      if (rule.appName == null && rule.title == null) {
        errors.add('Rule $i: must have either appName or title');
      }
      if (rule.layer != null && !WindowRule.validLayers.contains(rule.layer)) {
        errors.add('Rule $i: invalid layer "${rule.layer}"');
      }
    }

    // Validate signals
    for (int i = 0; i < config.signals.length; i++) {
      final signal = config.signals[i];
      if (!signal.isValidEvent) {
        errors.add('Signal $i: invalid event "${signal.event}"');
      }
      if (signal.action.isEmpty) {
        errors.add('Signal $i: action cannot be empty');
      }
    }

    return errors;
  }

  /// Validate that a SkhdConfig can be properly serialized
  static List<String> validateSkhdConfig(SkhdConfig config) {
    final errors = <String>[];

    for (int i = 0; i < config.shortcuts.length; i++) {
      final shortcut = config.shortcuts[i];

      if (shortcut.key.isEmpty) {
        errors.add('Shortcut $i: key cannot be empty');
      }

      if (shortcut.action.isEmpty) {
        errors.add('Shortcut $i: action cannot be empty');
      }

      if (!shortcut.hasValidModifiers) {
        errors.add('Shortcut $i: has invalid modifiers');
      }
    }

    // Check for duplicate hotkeys
    final hotkeys = <String>{};
    for (final shortcut in config.shortcuts) {
      if (!shortcut.enabled) continue;
      final hotkey = shortcut.toSkhdHotkey();
      if (hotkeys.contains(hotkey)) {
        errors.add('Duplicate hotkey: $hotkey');
      }
      hotkeys.add(hotkey);
    }

    return errors;
  }
}
