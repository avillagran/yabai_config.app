import 'dart:io';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../models/signal.dart';
import '../services/config_parser.dart';

/// State class for signals
class SignalsState {
  final List<YabaiSignal> signals;
  final bool isLoading;
  final String? error;

  const SignalsState({
    this.signals = const [],
    this.isLoading = false,
    this.error,
  });

  SignalsState copyWith({
    List<YabaiSignal>? signals,
    bool? isLoading,
    String? error,
  }) {
    return SignalsState(
      signals: signals ?? this.signals,
      isLoading: isLoading ?? this.isLoading,
      error: error,
    );
  }

  /// Get signals grouped by event type
  Map<String, List<YabaiSignal>> get signalsByEvent {
    final result = <String, List<YabaiSignal>>{};
    for (final signal in signals) {
      result.putIfAbsent(signal.event, () => []).add(signal);
    }
    return result;
  }

  /// Get enabled signals count
  int get enabledCount => signals.where((s) => s.enabled).length;
}

/// Notifier for managing signals state
class SignalsNotifier extends StateNotifier<SignalsState> {
  SignalsNotifier() : super(const SignalsState()) {
    _loadSignals();
  }

  /// Load signals directly from ~/.yabairc file
  Future<void> _loadSignals() async {
    state = state.copyWith(isLoading: true, error: null);

    try {
      final home = Platform.environment['HOME'] ?? '';
      final yabairc = File('$home/.yabairc');

      if (!await yabairc.exists()) {
        state = state.copyWith(signals: [], isLoading: false);
        return;
      }

      final content = await yabairc.readAsString();
      final config = ConfigParser.parseYabairc(content);
      state = state.copyWith(signals: config.signals, isLoading: false);
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: 'Failed to load signals: $e',
      );
    }
  }

  /// Add a new signal
  Future<void> addSignal(YabaiSignal signal) async {
    final newSignal = signal.copyWith(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
    );
    state = state.copyWith(
      signals: [...state.signals, newSignal],
    );
  }

  /// Update an existing signal
  Future<void> updateSignal(YabaiSignal signal) async {
    final index = state.signals.indexWhere((s) => s.id == signal.id);
    if (index != -1) {
      final updatedSignals = [...state.signals];
      updatedSignals[index] = signal;
      state = state.copyWith(signals: updatedSignals);
    }
  }

  /// Delete a signal
  Future<void> deleteSignal(String signalId) async {
    state = state.copyWith(
      signals: state.signals.where((s) => s.id != signalId).toList(),
    );
  }

  /// Toggle signal enabled state
  Future<void> toggleSignal(String signalId) async {
    final index = state.signals.indexWhere((s) => s.id == signalId);
    if (index != -1) {
      final signal = state.signals[index];
      final updatedSignal = signal.copyWith(enabled: !signal.enabled);
      await updateSignal(updatedSignal);
    }
  }

  /// Generate yabairc signal configuration
  String generateConfig() {
    final buffer = StringBuffer();
    buffer.writeln('# Signals Configuration');
    buffer.writeln('# Generated by Yabai Config');
    buffer.writeln();

    for (final signal in state.signals) {
      if (signal.enabled) {
        buffer.writeln(signal.toYabaiCommand());
      } else {
        buffer.writeln('# (disabled) ${signal.toYabaiCommand()}');
      }
    }

    return buffer.toString();
  }

  /// Refresh signals from file
  Future<void> refresh() async {
    await _loadSignals();
  }
}

/// Provider for signals state
final signalsProvider = StateNotifierProvider<SignalsNotifier, SignalsState>((ref) {
  return SignalsNotifier();
});
